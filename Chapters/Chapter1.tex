% Chapter 1
\stepcounter{cap}
%\chapter{cap1}
\label{cap1}

\mychapter{1}{Capitolul \arabic{cap} \\ DECIZII DE DESIGN}
%\chapter{\arabic{cap}.Introducere} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\thispagestyle{fancy}

%-----------------------------------------------------------------
În acest capitol sunt prezentate cele mai importante decizii de design luate în cadrul dezvoltării componentei software.

\section{Deciderea asupra modului de stocare a datelor} 

	\subsection{Subiectul problemei} 
	Nevoia modulului de a stoca şi de a accesa date stocate anterior.

	\subsection{Factori de decizie} 
	\begin{itemize}
	 \setlength\itemsep{0em}
		\item Consistenţa datelor stocate
		\item Utilizarea RAM-ului
		\item Timp de accesare la pornirea aplicaţiei
		\item Timp de accesare în cadrul aplicaţiei
		\item Spaţiul ocupat pe disc
		\item Compatibilitate cu versiunile anterioare
	\end{itemize}

	\subsection{Soluţii propuse}
	În următorul tabel, se presupune ca pentru fişierele binare, XML şi JSON este necesară încărcarea datelor la pornirea aplicaţiei. SQLite oferă însă soluţii de căutare inteligente, nefiind necesară încărcarea tuturor datelor la pornirea aplicaţiei.

	\begin{table}
	\caption{Compararea principalelor metode de stocare a datelor pe baza factorilor de influenţare}
	\resizebox{\textwidth}{!}{\begin{tabular}{ | c | c | c | c | c |}
	\hline
		& \textbf{Binar} & \textbf{XML sau JSON} & \textbf{SQLite} & \textbf{Memorare în Cloud} \\ 
	\hline
	 Consistenţa datelor stocate & Nu & Nu & Da & Da \\
	\hline
	 Utilizarea RAM-ului & Ridicat & Scăzut & Mediu & Mediu \\
	\hline
	 Timp de accesare la pornirea aplicaţiei & Mediu & Ridicat & Scăzut & Scăzut \\
	\hline
	 Timp de accesare în cadrul aplicaţiei & Scăzut & Scăzut & Mediu & Ridicat \\
	\hline
	 Spaţiul ocupat pe disc & Scăzut & Ridicat & Scăzut & Foarte scăzut \\
	\hline
	 Compatibilitate cu versiunile anterioare & Nu & Da & Da & Nu \\
	\hline
	\end{tabular}}
	\end{table}

	\subsection{Decizia}
	S-a decis folosirea SQLite ca format pentru baza de date deoarece îndeplinea toate criteriile specificate.

\section{Deciderea asupra comportamentului sincron/asincron} 

	\subsection{Subiectul problemei} 
	Există operaţii care ar putea necesita mai mult timp (>100ms) şi nu este vizibil direct faptul că acestea au fost declanşate de către o cerere (exemplu: o  nouă poziţie este trimisă).
	O cerere poate declanşată din fire de execuţie diferite.
	Există posibilitatea ca acest lucru sa fie realizat sincron, în afara modului, între cereri şi răspunsuri, fapt ce poate duce la deadlock.

	\subsection{Factori de decizie} 
	\begin{itemize}
	 \setlength\itemsep{0em}
		\item Timpul în care firul de execuţie este blocat de cerere
		\item Sincronizarea între operaţii
	\end{itemize}

	\subsection{Soluţii propuse}
	\begin{itemize}
	 \setlength\itemsep{0em}
		\item Procesul se va executa asincron folosind un fir de execuţie de lucru
		\item	Procesul se va executa sincron, în interiorul cererilor
	\end{itemize}


	\subsection{Decizia}
	Se vor furniza două interfeţe diferite. Funcţionalitatea va fi oferită printr-o interfaţă sincronă, ce va fi utilizată în cadrul operaţiilor ce au loc pe un singur fir de execuţie. O alta interfaţă va decupla firele de execuţie şi procesele într-o buclă de lucru.
	Acest fapt ne oferă libertatea utilizării principiului de multithread-ing (execuţia mai multor thread-uri în acelaşi pipeline, fiecare având propria secţiune de timp în care este menit să lucreze).


